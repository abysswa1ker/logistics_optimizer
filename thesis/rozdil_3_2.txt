3.2 Архітектура програмного комплексу

Архітектура програмного комплексу оптимізації логістичних мереж побудована на принципах модульності, розширюваності та незалежності компонентів [1]. Для організації коду обрано багатошарову архітектуру, яка забезпечує чітке розділення відповідальності між різними частинами системи та полегшує тестування та супровід програмного забезпечення [2].

Загальна структура програмного комплексу складається з п'яти основних шарів (рис. 3.1):

1. Шар моделі даних (models/) - описує предметну область
2. Шар сервісів (services/) - реалізує бізнес-логіку
3. Шар оптимізації (optimizers/) - містить алгоритми оптимізації
4. Шар утиліт (utils/) - допоміжні інструменти
5. Шар представлення (main.py) - інтерфейс користувача

Така архітектура відповідає принципам SOLID [3], зокрема принципу єдиної відповідальності (Single Responsibility Principle) та принципу відкритості/закритості (Open/Closed Principle).

3.2.1 Шар моделі даних

Шар моделі даних реалізує об'єктну модель предметної області логістичної мережі. Основними класами є:

- Element - базовий клас для всіх елементів мережі, що містить координати (x, y) та унікальний ідентифікатор
- Center - клас центрального розподільчого центру, успадковує Element
- Terminal - клас проміжного терміналу з параметрами вартості та продуктивності
- Consumer - клас споживача з параметром попиту
- LogisticsNetwork - клас, що агрегує всі елементи мережі

Використання успадкування дозволяє застосувати поліморфізм при обробці елементів мережі, що спрощує код та підвищує його читабельність [4]. Клас LogisticsNetwork відповідає за підтримку цілісності даних мережі та надає уніфікований інтерфейс для роботи з нею.

Діаграма класів моделі даних представлена на рисунку 3.2:

┌─────────────────┐
│    Element      │
├─────────────────┤
│ + id: int       │
│ + x: float      │
│ + y: float      │
└────────┬────────┘
         │
    ┌────┴──────────────┬─────────────┐
    │                   │             │
┌───▼──────┐    ┌───────▼────┐  ┌────▼──────┐
│  Center  │    │  Terminal  │  │ Consumer  │
├──────────┤    ├────────────┤  ├───────────┤
│          │    │ +cost:float│  │+demand:int│
│          │    │ +proc:float│  │           │
└──────────┘    └────────────┘  └───────────┘

        ┌────────────────────────┐
        │  LogisticsNetwork      │
        ├────────────────────────┤
        │ - center: Center       │
        │ - terminals: List      │
        │ - consumers: List      │
        ├────────────────────────┤
        │ + get_active_terminals()│
        │ + calculate_total_cost()│
        │ + clone(): Network     │
        └────────────────────────┘

Важливою особливістю класу LogisticsNetwork є метод clone(), який створює глибоку копію мережі [5]. Це необхідно для роботи генетичного алгоритму, де кожна особина популяції повинна мати незалежну копію мережі.

3.2.2 Шар сервісів

Шар сервісів містить модулі, що реалізують допоміжну бізнес-логіку системи:

DataLoader - завантаження даних з CSV файлів з валідацією формату та перевіркою коректності даних. Модуль підтримує різні кодування (UTF-8, UTF-8-BOM) для забезпечення сумісності з різними джерелами даних [6].

DistanceCalculator - обчислення Евклідової відстані між елементами мережі. Використовує векторизовані операції NumPy для підвищення продуктивності:

    d(A,B) = √[(x_B - x_A)² + (y_B - y_A)²]

де A та B - точки з координатами (x_A, y_A) та (x_B, y_B) відповідно [7].

CostCalculator - розрахунок цільової функції вартості мережі з урахуванням трьох компонент:

    C_total = C_fixed + C_processing + C_transport

де C_fixed - фіксовані витрати на утримання активних терміналів, C_processing - витрати на обробку товарів, C_transport - транспортні витрати [8].

Visualization - генерація наукових візуалізацій результатів оптимізації з використанням бібліотеки Matplotlib. Модуль створює графіки типу scatter plot для відображення географічного розташування елементів мережі та bar chart для порівняння результатів [9].

ResultExporter - експорт результатів у формат CSV з підтримкою різних кодувань. Використовує директиву "sep=," для коректного відкриття файлів у Microsoft Excel з локалізованими налаштуваннями [10].

3.2.3 Шар оптимізації

Шар оптимізації реалізує патерн проектування Strategy [11], що дозволяє динамічно змінювати алгоритм оптимізації без зміни клієнтського коду. Архітектура цього шару показана на рисунку 3.3:

        ┌─────────────────────┐
        │  BaseOptimizer      │◄───────────┐
        ├─────────────────────┤            │
        │ # network: Network  │            │
        │ # history: List     │            │
        ├─────────────────────┤            │
        │ + optimize(): Dict  │◄─interface─┤
        │ # evaluate(): float │            │
        └──────────┬──────────┘            │
                   │                       │
        ┌──────────┴──────────┐            │
        │                     │            │
┌───────▼─────────┐  ┌────────▼──────────┐│
│CoordinateOptimizer│ │GeneticOptimizer   ││
├─────────────────┤  ├───────────────────┤│
│-max_iter: int   │  │-population: int   ││
│-tolerance:float │  │-generations: int  ││
├─────────────────┤  │-mutation_rate:float││
│+optimize():Dict │  │-crossover_rate:float││
└─────────────────┘  ├───────────────────┤│
                     │+optimize(): Dict  ││
                     └───────────────────┘│
                                          │
                    ┌─────────────────────┘
                    │ uses
        ┌───────────▼──────────┐
        │   main.py            │
        ├──────────────────────┤
        │ optimizer = MPO/GA   │
        │ results = optimize() │
        └──────────────────────┘

Базовий абстрактний клас BaseOptimizer визначає спільний інтерфейс для всіх алгоритмів оптимізації та реалізує загальну функціональність, таку як збереження історії оптимізації та обчислення цільової функції [12].

CoordinateOptimizer реалізує метод покоординатного спуску (МПО), який виконує детерміністичний локальний пошук. Основні параметри:
- max_iterations - максимальна кількість ітерацій
- tolerance - мінімальне покращення для продовження оптимізації

GeneticOptimizer реалізує еволюційно-модифікований генетичний алгоритм (ЕМ-ГА) для глобального пошуку оптимуму. Параметри налаштування:
- population_size - розмір популяції (типово 100 особин)
- generations - кількість поколінь (типово 50)
- mutation_rate - ймовірність мутації (0.1)
- crossover_rate - ймовірність схрещування (0.8)

Використання патерну Strategy дозволяє легко додавати нові алгоритми оптимізації без модифікації існуючого коду, що відповідає принципу відкритості/закритості [13].

3.2.4 Потік даних в системі

Загальний потік даних в програмному комплексі можна описати наступною послідовністю кроків:

1. Завантаження даних: DataLoader зчитує CSV файл та створює об'єкти моделі даних
2. Ініціалізація мережі: створюється об'єкт LogisticsNetwork з усіма елементами
3. Оцінка початкового стану: CostCalculator обчислює початкову вартість мережі
4. Оптимізація: обраний оптимізатор (MPO або GA) виконує пошук оптимального розміщення терміналів
5. Візуалізація: Visualization створює графіки до/після оптимізації
6. Експорт: ResultExporter зберігає результати у CSV формат

Така послідовність забезпечує лінійний потік даних без зворотних залежностей, що спрощує розуміння системи та її налагодження [14].

3.2.5 Обробка помилок та валідація

Система містить багатошарову систему валідації даних:

Шар 1 - валідація формату CSV: перевірка наявності всіх необхідних колонок, коректність типів даних, відсутність пропущених значень.

Шар 2 - валідація бізнес-правил: перевірка того, що мережа містить рівно один центр, принаймні один термінал та один споживач; всі координати невід'ємні; вартості коректні.

Шар 3 - валідація під час оптимізації: перевірка, що нова конфігурація не погіршує якість мережі більше ніж допустимо.

Використання винятків (exceptions) для обробки помилок відповідає рекомендаціям PEP 8 та забезпечує коректне завершення роботи програми у випадку некоректних даних [15].

3.2.6 Масштабованість архітектури

Обрана архітектура забезпечує можливість масштабування системи в кількох напрямках:

Горизонтальне масштабування - додавання нових алгоритмів оптимізації через реалізацію інтерфейсу BaseOptimizer без зміни інших компонентів системи.

Вертикальне масштабування - паралелізація обчислень в генетичному алгоритмі через використання модуля multiprocessing для обчислення fitness-функції популяції [16].

Функціональне масштабування - додавання нових типів візуалізацій, експорту в інші формати (JSON, XML), інтеграції з базами даних.

Модульна архітектура з чітко визначеними інтерфейсами між компонентами забезпечує можливість незалежного розвитку різних частин системи [17].

3.2.7 Тестування архітектури

Для перевірки коректності реалізації архітектури використано інструменти:

- Генератор тестових мереж (utils/network_generator.py) - створює синтетичні мережі різних розмірів для тестування масштабованості
- Система пакетного тестування (utils/batch_test.py) - автоматизує порівняння алгоритмів на множині тестових мереж
- Статичний аналізатор pylint - перевіряє відповідність коду стандартам PEP 8

Результати тестування підтверджують коректність архітектурних рішень та ефективність обраного підходу до організації коду [18].

Таким чином, розроблена архітектура програмного комплексу забезпечує модульність, розширюваність, тестованість та підтримуваність системи оптимізації логістичних мереж. Використання перевірених патернів проектування та принципів об'єктно-орієнтованого програмування гарантує високу якість програмного забезпечення.


Список використаних джерел до розділу 3.2:

[1] Martin R. C. Clean Architecture: A Craftsman's Guide to Software Structure and Design. Prentice Hall, 2017. 432 p.

[2] Fowler M. Patterns of Enterprise Application Architecture. Addison-Wesley Professional, 2002. 560 p.

[3] Martin R. C. Agile Software Development, Principles, Patterns, and Practices. Prentice Hall, 2002. 529 p.

[4] Bloch J. Effective Java. 3rd ed. Addison-Wesley Professional, 2018. 416 p.

[5] Freeman E., Robson E., Sierra K., Bates B. Head First Design Patterns. 2nd ed. O'Reilly Media, 2020. 672 p.

[6] Beazley D. Python Essential Reference. 4th ed. Addison-Wesley Professional, 2009. 717 p.

[7] Strang G. Introduction to Linear Algebra. 5th ed. Wellesley-Cambridge Press, 2016. 584 p.

[8] Ballou R. H. Business Logistics/Supply Chain Management. 5th ed. Prentice Hall, 2004. 789 p.

[9] Hunter J. D. Matplotlib: A 2D graphics environment. Computing in Science & Engineering. 2007. Vol. 9, No. 3. P. 90-95. DOI: 10.1109/MCSE.2007.55.

[10] Shafranovich Y. Common Format and MIME Type for Comma-Separated Values (CSV) Files. RFC 4180, 2005. URL: https://www.rfc-editor.org/rfc/rfc4180 (дата звернення: 12.01.2025).

[11] Gamma E., Helm R., Johnson R., Vlissides J. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley Professional, 1994. 395 p.

[12] Ramalho L. Fluent Python: Clear, Concise, and Effective Programming. 2nd ed. O'Reilly Media, 2022. 1012 p.

[13] Phillips D. Python 3 Object-Oriented Programming. 3rd ed. Packt Publishing, 2018. 466 p.

[14] Evans E. Domain-Driven Design: Tackling Complexity in the Heart of Software. Addison-Wesley Professional, 2003. 560 p.

[15] van Rossum G., Warsaw B., Coghlan N. PEP 8 – Style Guide for Python Code. Python Enhancement Proposals. 2001. URL: https://peps.python.org/pep-0008/ (дата звернення: 12.01.2025).

[16] Gorelick M., Ozsvald I. High Performance Python: Practical Performant Programming for Humans. 2nd ed. O'Reilly Media, 2020. 468 p.

[17] Newman S. Building Microservices: Designing Fine-Grained Systems. 2nd ed. O'Reilly Media, 2021. 612 p.

[18] Percival H., Gregory B. Architecture Patterns with Python: Enabling Test-Driven Development, Domain-Driven Design, and Event-Driven Microservices. O'Reilly Media, 2020. 304 p.
